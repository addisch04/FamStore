Projektdokumentation: FamStore App
Das Projekt üéØ
Die Entwicklung einer ersten mobilen App f√ºr Android mit dem Ziel, die Grundlagen von React Native und Expo zu lernen. Das Projekt hei√üt "FamStore".

Ziel der App: Eine mobile App, welche die Vereinfachung der Hausversorgung und die √úbersichtsbehaltung erm√∂glicht.

GitHub Repo: https://github.com/addisch04/FamStore

Kenntnisstand: Anf√§nger

Technologie-Stack ‚ÑπÔ∏è
Frontend (Mobile App): React Native, Expo, TypeScript

Backend (API): Node.js, Express (geplant f√ºr Vercel Deployment)

Datenbank: Turso (Cloud-basiertes SQLite)

Versionskontrolle: Git

Aktueller Stand der Implementierung ‚úÖ
Der anf√§ngliche Stand eines leeren Templates wurde signifikant erweitert. Die App verf√ºgt nun √ºber ein solides, komponentenbasiertes UI-Fundament f√ºr die Kernfunktionen.

Navigations-Struktur:

Eine voll funktionsf√§hige Tab-Bar mit f√ºnf benutzerdefinierten Tabs (Start, Vorrat, Liste, Rezepte, Profil) wurde implementiert.

Eine globale, wiederverwendbare Top-Bar (Header) mit navigierbarem Logo und Profil-Icon ist auf allen Hauptseiten sichtbar.

UI-Implementierung:

Home-Screen: Visuell vollst√§ndig implementiert mit wiederverwendbaren Komponenten f√ºr Dashboard, "Bald ablaufend"-Karussell, Schnell-Aktionen und Rezeptvorschl√§gen. Das Layout ist f√ºr typische Smartphone-Bildschirme optimiert.

Vorrat-Screen: Das UI ist fertiggestellt und interaktiv. Es enth√§lt eine Suchleiste, eine zweizeilige Filter-Leiste und eine Artikelliste in einem 3-spaltigen Grid-Layout. Die Filterung der (Dummy-)Daten funktioniert.

Einkaufslisten-Screen: Das UI ist fertiggestellt und interaktiv. Es enth√§lt ein Eingabefeld, ein 2x2 Grid f√ºr Aktionen und eine interaktive Artikelliste in einem 4-spaltigen, quadratischen Grid-Layout. Artikel k√∂nnen abgehakt werden und verschieben sich in eine einklappbare "Erledigt"-Sektion.

Platzhalter-Screens: Die restlichen Screens (recipes, profile) sind mit sauberen Platzhaltern bef√ºllt.

Backend & Datenbank:

Die Turso-Datenbank (famstore-db) wurde in der Cloud erstellt und ist betriebsbereit.

Die initiale Datenbank-Struktur (Schema) f√ºr die Tabellen pantry_items und shopping_list_items wurde definiert und in der Datenbank angelegt.

Projekt-Architektur & Aufbau
Die App folgt einem modernen, modularen Aufbau, der auf Wiederverwendbarkeit und klarer Trennung der Verantwortlichkeiten basiert.

Frontend-Architektur:

Expo Router wird f√ºr das dateibasierte Routing verwendet. Die app/(tabs)/_layout.tsx ist die zentrale Steuerdatei f√ºr die Hauptansicht.

Die UI ist in √ºber 15 wiederverwendbare Komponenten (z.B. ProductCard, FilterControls, ShoppingListItem) im /components-Ordner aufgeteilt. Dies h√§lt die Screen-Dateien (/app/(tabs)) sauber und f√∂rdert die Konsistenz.

State Management f√ºr die UI-Interaktivit√§t wird √ºber React Hooks (useState, useMemo) gehandhabt. Das "State Lifting"-Prinzip wird genutzt, damit √ºbergeordnete Komponenten (z.B. PantryScreen) den Zustand f√ºr untergeordnete Komponenten (z.B. FilterControls) verwalten k√∂nnen.

Geplante n√§chste Schritte: Backend-Implementierung üó∫Ô∏è
Der Fokus liegt nun auf der Erstellung eines Backends und der Anbindung der App an die reale Datenbank, um die DUMMY_DATA zu ersetzen. Dies wird in drei Phasen umgesetzt.

Phase 1: Backend-Entwicklung (Vercel & Node.js)

Ein neues, separates Node.js-Projekt f√ºr das Backend wird aufgesetzt.

Installation der notwendigen Bibliotheken (express f√ºr das Routing, @libsql/client f√ºr die Turso-Verbindung).

Erstellung von API-Endpunkten f√ºr alle notwendigen Aktionen:

GET /api/pantry: Alle Vorratsartikel abrufen.

POST /api/pantry: Einen neuen Artikel zum Vorrat hinzuf√ºgen.

GET /api/shopping-list: Alle Einkaufslisten-Artikel abrufen.

POST /api/shopping-list: Einen neuen Artikel zur Einkaufsliste hinzuf√ºgen.

PUT /api/shopping-list/:id: Den is_checked-Status eines Artikels aktualisieren.

DELETE /api/pantry/:id & DELETE /api/shopping-list/:id: Artikel l√∂schen.

Sichere Konfiguration der Datenbank-Zugangsdaten √ºber Environment Variables.

Deployment des fertigen Backends auf Vercel, um eine √∂ffentliche API-URL zu erhalten.

Phase 2: App-Integration (React Native)

Entfernen aller DUMMY_DATA-Arrays in den Screen-Dateien.

Implementierung von Datenabruf-Logik mithilfe des useEffect-Hooks und der fetch-API, um beim Laden der Screens Daten vom Vercel-Backend zu laden.

Einbau von Lade- und Fehlerzust√§nden in der UI (z.B. Anzeige eines Lade-Spinners).

Anpassung der Aktions-Buttons und Eingabefelder, sodass sie POST-, PUT- oder DELETE-Anfragen an das Backend senden, anstatt nur den lokalen State zu √§ndern.

Phase 3: Finalisierung & weitere Screens

Entwicklung des UIs f√ºr die verbleibenden Screens ("Rezepte", "Profil").

Implementierung der fortgeschrittenen Aktionen wie "Einkauf abschlie√üen" (√ºbertr√§gt Artikel von der Einkaufsliste in den Vorrat).

Implementierung der Wisch-Gesten (Swipe Actions) f√ºr schnelles L√∂schen im Vorrat-Tab.